//  Що повинен відпрацювати та продемонструвати викладач на уроці:
// 1. Основні завдання

// a - Створити проміс і продемонструвати, що він повертає та стани в яких він може перебувати

// console.log("test 1");
// const promise1 = new Promise((res, reg) => {
//   setTimeout(() => {
//     console.log("setTimeout 5000", promise1);
//     res("resolve");
//   }, 5000);
// })

// b - Отримати результат промісу за допомогою методу then()

// console.log("test 2");
// const promise1 = new Promise((res, reg) => {
//   setTimeout(() => {
//     console.log("setTimeout 1000", promise1);
//     res("resolve test");
//   }, 1000);
// }).then((result) => {
//   console.log("result 1", result);
//   console.log(promise1);
// });

// c - Відловити помилку використовуючи метод catch()

// console.log("test 2");
// const promise1 = new Promise((res, reg) => {
//   res("some error test");
// }).then((result) => {
//   console.log("result 1", result);
//   console.log(promise1);
//   throw Error('test')
// }).catch((error)=>{
//   console.log("error 1", error);
// })

// d - Вивести на екран повідомлення, яке буде виконуватися не зважаючи
// на результат виконання промісу за
//  допомогою методу finally()

// const promise1 = new Promise((res, reg) => {
//   res("some error test");
// })
//   .then((result) => {
//     console.log("result 1", result);
//     console.log(promise1);
//     throw Error("test");
//   })
//   .catch((error) => {
//     console.log("error 1", error);
//     console.log(promise1);
//   });
// .finally(() => {
//   console.log("finally", promise1);
// });

// promise1.finally(() => {
//   console.log("finally", promise1);
// });

// e - Продемонструвати ланцюжок промісів, використовуючи приклад з конспекту або власний,
//  тим самим опрацювати, що кожен наступний then отримує результат попереднього

// const promise1 = new Promise((res, reg) => {
//   res(2);
// });
// .then

// promise1
//   .then((value) => {
//     console.log(value); // 2
//     return value + 1;
//   })
//   .then((value) => {
//     console.log(value); // 3
//     return value * 2;
//   })
//   .then((value) => {
//     console.log(value); // 6
//     return value + 10;
//   })
//   .then((value) => {
//     console.log(value); // 16
//   });

// promise1 // прийняло 2
//   .then((value) => {
//     // console.log(value); // 2
//     return value + 1;
//   })
//   .then((value) => {
//     // console.log(value); // 3
//     return value * 2;
//   })
//   .then((value) => {
//     console.log(value); // 6
//   });

// promise1 // прийняло 2
//   .then((value) => {
//     // console.log(value); // 2
//     return value + 10;
//   })
//   .then((value) => {
//     console.log(value); // 12
//   });

// f - Зробити промісифікацію функції і використати на результаті її виконання методи then(),
//  catch(), finally()

// 2. Додаткові завдання

// 1 Що виведе код нижче?

// const time = Date.now();
// let promise = new Promise(function (resolve, reject) {
//   // resolve(1);
//   console.log(time - Date.now());
//   setTimeout(() => {
//     console.log(time - Date.now());
//     resolve(1000);
//   }, 1000);
//   // setTimeout(() => resolve(100), 100);
//   // setTimeout(() => resolve(0), 0);
//   // setTimeout(() => resolve("null false"));
// });

// promise.then(alert);

// promise.then((v) => {
//   console.log(v);
//   console.log(time - Date.now());
// });

// 2 Вбудована функція setTimeout використовує колбек-функції.
// Створіть альтернативу яка базується на промісах.
// Функція delay(ms) повинна повертати проміс, який перейде в стан resolved через ms мілісекунд,
// ак щоб ми могли додати до нього .then:

// створення промісу це звичайна таска
// всередені створється макро з сеттаймаута і стає в чергу макро(бо вони є макро)
// а коли виконається макро(setTimeout) тоді викличеться res який є промісом(і всі його цепочкі з then)
// і який викличеться після макро перед наступним макро 

function delay(ms = 0, value = undefined) {
  return new Promise((res) => {
    console.log("таска створення промісу");
    setTimeout(() => {
      console.log("виконання макро");
      res(value);
    }, ms);
  });
}

// таска  - якщо є проміси - макро (таски всередині макро - мікро всередині )
// - макро (таски всередині макро - мікро всередині )
// - макро (таски всередині макро - мікро всередині )
// - макро (таски всередині макро - мікро всередині )

console.log("1 таска");

delay(3000).then(() => {
  console.log(" мікро виконалось через 3 секунди");
});
console.log("2 таска");
delay(2000)
  .then(() => console.log("мікро виконалось через 2 секунди"))
  .then(() => console.log(" 2 мікро виконалось через 2 секунди"));
delay(2000).then(() => console.log("мікро виконалось через 2222 секунди"));
delay(5, 100).then((e) =>
  console.log("мікро виконалось через 5 мілісекунд", e)
);
delay().then((e) => console.log("мікро виконалось через 0 секунди", e));

let name1 = setInterval(() => {
  console.log("setInterval", Date.now());
}, 1000);

delay(5000).then(() => clearInterval(name1));

console.log("3 таска");
// setTimeout(() => {

//   console.log("clearInterval");
// }, 5000);

// 3.  Напишіть функцію, яка повертає проміс, який виконується через певний час (наприклад, 2 секунди)
//  і повертає повідомлення "Проміс виконано".

delay(2000, "Проміс виконано").then((e) => console.log(e));

// 3. Творчі завдання

// Напишіть функцію, яка отримує масив чисел і повертає проміс, який виконується, якщо всі числа в масиві
//  є парними. Якщо ж принаймні одне число непарне, проміс повинен бути відхилено з повідомленням "Є непарні числа".
// Напишіть функцію, яка приймає URL зображення і повертає проміс, який завантажує це зображення.
//  Якщо завантаження успішне, проміс виконується з завантаженим зображенням, а в разі помилки - відхиляється
//   з повідомленням про помилку.
// Напишіть функцію, яка отримує масив об'єктів  і повертає проміс, який виконується з масивом імен,
//  відсортованих за алфавітом.
// const people = [
//     { name: "John", age: 25 },
//     { name: "Anna", age: 30 },
//     { name: "Peter", age: 40 },
//     { name: "Mary", age: 35 },
//   ];

// Напишіть функцію, яка приймає два числа і повертає проміс, який виконується з результатом їхнього додавання.
//  Якщо хоча б одне з чисел не є числом, проміс повинен бути відхилено з повідомленням "Неправильні аргументи".

// 4.Суперворчі завдання
// Випадковий проміс
// Створіть функцію randomPromise, яка повертає проміс, який випадковим чином виконується або відхиляється.
// Використайте метод then, щоб обробити виконання проміса та вивести повідомлення "Проміс виконано".
// Використайте метод catch, щоб обробити помилку, якщо проміс відхиляється, і вивести повідомлення
//  "Помилка проміса".
// Використайте метод finally для виведення повідомлення "Робота з промісом завершена" незалежно від того,
//  чи було виконання успішним, чи виникла помилка.
// Послідовний проміс
// Створіть функцію getRandomNumber, яка повертає проміс, що генерує випадкове число.
// Використайте метод then, щоб обробити результат першого проміса, додати до нього число 10 та вивести результат.
// Використайте метод catch, щоб обробити помилки у будь-якому з промісів та вивести повідомлення "Помилка проміса".
// Використайте метод finally для виведення повідомлення "Робота з промісом завершена" незалежно від того,
//  чи було виконання успішним, чи виникла помилка.
